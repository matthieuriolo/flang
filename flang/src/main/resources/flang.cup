package ch.ffhs.fac.flang.parser;

import ch.ffhs.fac.flang.runtime.*;
import ch.ffhs.fac.flang.runtime.expressions.*;
import ch.ffhs.fac.flang.runtime.expressions.operations.*;
import ch.ffhs.fac.flang.runtime.instructions.*;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.math.BigDecimal;

parser code {:
   
:};


/** Terminals */

// keywords

terminal     TRUE, FALSE, UNDEFINED;
terminal     AND, OR;
terminal     FOR, FROM, TO, BY;
terminal     WHILE;
terminal     IF, ELSE;
terminal     END, RETURN;
	
// brackets
terminal     ROUND_OPEN, ROUND_CLOSED, CURLY_OPEN, CURLY_CLOSED;

// arithmetic
terminal     ASSIGN, COLON, COMMA, PLUS, MINUS, ASTERISK, SLASH;
terminal     EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
terminal     UMINUS;


// literals
terminal String IDENTIFIER;
terminal String STRING;
terminal BigDecimal DECIMAL;


/** Non-Terminals */
non terminal Document document;
non terminal List<Instruction> instructions;
non terminal Instruction instruction;

non terminal Instruction if;
non terminal Instruction for;
non terminal Instruction while;
non terminal Instruction assignment;
non terminal Expression functionCall;
non terminal Instruction functionProcedure;
non terminal LinkedList<ch.ffhs.fac.flang.runtime.literals.Identifier> functionArguments;
non terminal Literal functionDeclaration;
non terminal LinkedList<Expression> expressions;
non terminal Expression expression;
/*
We keep this for now - it has been replaced by "%prec" and "precedence left"
non terminal Expression expressionPriority1;
non terminal Expression expressionPriority2;
non terminal Expression expressionPriority3;
non terminal Expression expressionPriority4;
non terminal Expression expressionPriority5;
non terminal Expression expressionPriority6;
non terminal Expression expressionPriority7;
non terminal Expression expressionPriority8;
*/

non terminal Literal literal;
non terminal ch.ffhs.fac.flang.runtime.literals.Identifier identifier;
/** Precedences */
precedence left OR;
precedence left AND;

precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH;
precedence left UMINUS;


/** ============= GRAMMAR ============= */

start with document;

document             ::= instructions:i                 {: RESULT = new Document(i); :};
instructions         ::= instructions:l instruction:i   {: RESULT = l; l.add(i); :}
                       | instruction:i                  {: RESULT = new LinkedList<Instruction>(); RESULT.add(i); :}
;

instruction          ::= assignment:i                   {: RESULT = i; :}
                       | END                            {: RESULT = new Return(); :}
                       | RETURN expression:i            {: RESULT = new Return(i); :}
                       | if:i                           {: RESULT = i; :}
                       | while:i                        {: RESULT = i; :}
                       | for:i                          {: RESULT = i; :}
                       | functionProcedure:i            {: RESULT = i; :}
;

/* instructions */
assignment           ::= identifier:i ASSIGN expression:e                   {: RESULT = new Assignment(i, e); :};
functionProcedure    ::= identifier:i ROUND_OPEN expressions:e ROUND_CLOSED {: RESULT = new FunctionProcedure(i, e); :}
           /*            | functionCall ROUND_OPEN expressions:e ROUND_CLOSED {: :}*/
;


if                   ::= IF expression:e CURLY_OPEN instructions:i CURLY_CLOSED                                             {: RESULT = new If(e, i); :}
                       | IF expression:e CURLY_OPEN instructions:i CURLY_CLOSED ELSE CURLY_OPEN instructions:o CURLY_CLOSED {: RESULT = new If(e, i, o); :}
;
while                ::= WHILE expression:e CURLY_OPEN instructions:i CURLY_CLOSED                                                    {: RESULT = new While(e, i); :};
for                  ::= FOR identifier:i TO expression:t CURLY_OPEN instructions:s CURLY_CLOSED                                      {: RESULT = new For(i, BigDecimal.ZERO, t, BigDecimal.ONE, s); :}
                       | FOR identifier:i TO expression:t BY expression:b CURLY_OPEN instructions:s CURLY_CLOSED                      {: RESULT = new For(i, BigDecimal.ZERO, t, b, s); :}
                       | FOR identifier:i FROM expression:f TO expression:t CURLY_OPEN instructions:s CURLY_CLOSED                    {: RESULT = new For(i, f, t, BigDecimal.ONE, s); :}
                       | FOR identifier:i FROM expression:f TO expression:t BY expression:b CURLY_OPEN instructions:s CURLY_CLOSED    {: RESULT = new For(i, f, t, b, s); :}
;


/* expressions */
expressions          ::= expressions:l COMMA expression:i {: RESULT = l; l.add(i); :}
                       | expression:i                     {: RESULT = new LinkedList<Expression>(); RESULT.add(i); :}
;


expression           ::= expression:l OR expression:r              {: RESULT = new BiOperand(l, BiOperand.Type.OR, r); :}
                       | expression:l AND expression:r             {: RESULT = new BiOperand(l, BiOperand.Type.AND, r); :}
                       | expression:l EQUAL expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.EQUAL, r); :}
                       | expression:l NOT_EQUAL expression:r       {: RESULT = new BiOperand(l, BiOperand.Type.NOT_EQUAL, r); :}
                       | expression:l LESS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.LESS, r); :}
                       | expression:l LESS_EQUAL expression:r      {: RESULT = new BiOperand(l, BiOperand.Type.LESS_EQUAL, r); :}
                       | expression:l GREATER expression:r         {: RESULT = new BiOperand(l, BiOperand.Type.GREATER, r); :}
                       | expression:l GREATER_EQUAL expression:r   {: RESULT = new BiOperand(l, BiOperand.Type.GREATER_EQUAL, r); :}
                       | expression:l PLUS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.PLUS, r); :}
                       | expression:l MINUS expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.MINUS, r); :}
                       | expression:l ASTERISK expression:r        {: RESULT = new BiOperand(l, BiOperand.Type.ASTERISK, r); :}
                       | expression:l SLASH expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.SLASH, r); :}
                       | MINUS expression:i                        {: RESULT = new UnaryOperand(i, UnaryOperand.Type.MINUS); :} %prec UMINUS
                       | ROUND_OPEN expression:i ROUND_CLOSED      {: RESULT = i; :}
                       | functionCall:i                            {: RESULT = i; :}
                       | literal:i                                 {: RESULT = new LiteralWrapper(i); :}
;

/*
 Older versions of CUP forced the user to write unambiguous grammars, but now there is a construct allowing the
 user to specify precedences and associativities for terminals.
expression           ::= expressionPriority1;
expressionPriority1  ::= expressionPriority1 OR expressionPriority2
                       | expressionPriority2
;
expressionPriority2  ::= expressionPriority2 AND expressionPriority3
                       | expressionPriority3
;
expressionPriority3  ::= expressionPriority3 EQUAL expressionPriority4
                       | expressionPriority3 NOT_EQUAL expressionPriority4
                       | expressionPriority4
;
expressionPriority4  ::= expressionPriority4 LESS expressionPriority5
                       | expressionPriority4 LESS_EQUAL expressionPriority5
                       | expressionPriority4 GREATER expressionPriority5
                       | expressionPriority4 GREATER_EQUAL expressionPriority5
                       | expressionPriority5
;
expressionPriority5  ::= expressionPriority5 PLUS expressionPriority6
                       | expressionPriority5 MINUS expressionPriority6
                       | expressionPriority6
;
expressionPriority6  ::= expressionPriority6 ASTERISK expressionPriority7
                       | expressionPriority6 SLASH expressionPriority7
                       | expressionPriority7
;
expressionPriority7  ::= MINUS expressionPriority8
                       | expressionPriority8
;
expressionPriority8  ::= ROUND_OPEN expression:i ROUND_CLOSED
                       | literal
;
*/

/* operators */


/* literals */
literal              ::= identifier:i          {: RESULT = i; :}
                       | DECIMAL:i             {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Decimal(i); :}
                       | TRUE                  {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.TRUE; :}
                       | FALSE                 {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.FALSE; :}
                       | UNDEFINED             {: RESULT = ch.ffhs.fac.flang.runtime.literals.Undefined.UNDEFINED; :}
                       | functionDeclaration:i {: RESULT = i; :}
                       | STRING:i              {: RESULT = new ch.ffhs.fac.flang.runtime.literals.String(i); :}
;

identifier           ::= IDENTIFIER:i          {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Identifier(i); :};

functionDeclaration  ::= COLON ROUND_OPEN functionArguments:a ROUND_CLOSED CURLY_OPEN instructions:i CURLY_CLOSED   {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Function(a, i); :};
functionArguments    ::= functionArguments:l COMMA identifier:i {: RESULT = l;  l.add(i); :}
                       | identifier:i {: RESULT = new LinkedList<ch.ffhs.fac.flang.runtime.literals.Identifier>(); RESULT.add(i); :}
;
functionCall         ::= identifier:i ROUND_OPEN expressions:e ROUND_CLOSED              {: RESULT = new FunctionCall(i, e); :};