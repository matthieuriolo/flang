package ch.ffhs.fac.flang.parser;

import ch.ffhs.fac.flang.runtime.*;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:
   
:};


/** Terminals */

// keywords

terminal     TRUE, FALSE, UNDEFINED;
terminal     AND, OR;
terminal     FOR, FROM, TO, BY;
terminal     WHILE;
terminal     IF, ELSE;
terminal     END, RETURN;
	
// brackets
terminal     ROUND_OPEN, ROUND_CLOSED, CURLY_OPEN, CURLY_CLOSED, SQUARE_OPEN, SQUARE_CLOSED;

// arithmetic
terminal     ASSIGN, COLON, COMMA, PLUS, MINUS, ASTERISK, SLASH;
terminal     EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
terminal     UMINUS;


// literals
terminal     IDENTIFIER, STRING, INTEGER;


/** Non-Terminals */
non terminal Document document;
non terminal Closure instructions;
non terminal Instruction instruction;

non terminal Instruction if;
non terminal Instruction for;
non terminal Instruction while;
non terminal Instruction assignment;
non terminal Expression functionCall;
non terminal LinkedList<Identifier> functionArguments;
non terminal Expression functionDeclaration;
non terminal LinkedList<Expression> expressions;
non terminal Expression expression;
/*
We keep this for now
non terminal Expression expressionPriority1;
non terminal Expression expressionPriority2;
non terminal Expression expressionPriority3;
non terminal Expression expressionPriority4;
non terminal Expression expressionPriority5;
non terminal Expression expressionPriority6;
non terminal Expression expressionPriority7;
non terminal Expression expressionPriority8;
*/

non terminal Literal literal;

/** Precedences */
precedence left OR;
precedence left AND;

precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH;
precedence left UMINUS;


/** ============= GRAMMAR ============= */

start with document;

document             ::= instructions:i                 {: RESULT = new Document(); :};
instructions         ::= instructions:l instruction:i   {: l.addInstruction(i); :}
                       | instruction:i                  {: RESULT = new Closure(); RESULT.addInstruction(i); :}
;

instruction          ::= assignment                     {: :}
                       | END                            {: :}
                       | RETURN expression              {: :}
                       | if                             {: :}
                       | while                          {: :}
                       | for                            {: :}
                       | functionCall                   {: :}
;

/* instructions */
assignment           ::= IDENTIFIER ASSIGN expression   {: :};
functionCall         ::= IDENTIFIER functionArguments   {: :};
functionArguments    ::= ROUND_OPEN expression COMMA ROUND_CLOSED         {: :};


if                   ::= IF expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | IF expression CURLY_OPEN instructions CURLY_CLOSED ELSE CURLY_OPEN instructions CURLY_CLOSED {: :}
;
while                ::= WHILE expression CURLY_OPEN instructions CURLY_CLOSED {: :};
for                  ::= FOR IDENTIFIER TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR IDENTIFIER BY expression TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR IDENTIFIER FROM expression TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR IDENTIFIER FROM expression BY expression TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
;


/* expressions */
expressions          ::= expressions:l COMMA expression:i {: l.add(i); :}
                       | expression:i                     {: RESULT = new LinkedList<Expression>(); RESULT.add(i); :}
;


expression           ::= expression:l OR expression:r              {: RESULT = new BiOperand(l, BiOperand.Type.OR, r); :}
                       | expression:l AND expression:r             {: RESULT = new BiOperand(l, BiOperand.Type.AND, r); :}
                       | expression:l EQUAL expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.EQUAL, r); :}
                       | expression:l NOT_EQUAL expression:r       {: RESULT = new BiOperand(l, BiOperand.Type.NOT_EQUAL, r); :}
                       | expression:l LESS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.LESS, r); :}
                       | expression:l LESS_EQUAL expression:r      {: RESULT = new BiOperand(l, BiOperand.Type.LESS_EQUAL, r); :}
                       | expression:l GREATER expression:r         {: RESULT = new BiOperand(l, BiOperand.Type.GREATER, r); :}
                       | expression:l GREATER_EQUAL expression:r   {: RESULT = new BiOperand(l, BiOperand.Type.GREATER_EQUAL, r); :}
                       | expression:l PLUS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.PLUS, r); :}
                       | expression:l MINUS expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.MINUS, r); :}
                       | expression:l ASTERISK expression:r        {: RESULT = new BiOperand(l, BiOperand.Type.ASTERISK, r); :}
                       | expression:l SLASH expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.SLASH, r); :}
                       | MINUS expression                          {: RESULT = new UnaryOperand(i, UnaryOperand.Type.Minus); :} %prec UMINUS
                       | ROUND_OPEN expression:i ROUND_CLOSED
                       | literal
;

/*
 Older versions of CUP forced the user to write unambiguous grammars, but now there is a construct allowing the
 user to specify precedences and associativities for terminals.
expression           ::= expressionPriority1;
expressionPriority1  ::= expressionPriority1 OR expressionPriority2
                       | expressionPriority2
;
expressionPriority2  ::= expressionPriority2 AND expressionPriority3
                       | expressionPriority3
;
expressionPriority3  ::= expressionPriority3 EQUAL expressionPriority4
                       | expressionPriority3 NOT_EQUAL expressionPriority4
                       | expressionPriority4
;
expressionPriority4  ::= expressionPriority4 LESS expressionPriority5
                       | expressionPriority4 LESS_EQUAL expressionPriority5
                       | expressionPriority4 GREATER expressionPriority5
                       | expressionPriority4 GREATER_EQUAL expressionPriority5
                       | expressionPriority5
;
expressionPriority5  ::= expressionPriority5 PLUS expressionPriority6
                       | expressionPriority5 MINUS expressionPriority6
                       | expressionPriority6
;
expressionPriority6  ::= expressionPriority6 ASTERISK expressionPriority7
                       | expressionPriority6 SLASH expressionPriority7
                       | expressionPriority7
;
expressionPriority7  ::= MINUS expressionPriority8
                       | expressionPriority8
;
expressionPriority8  ::= ROUND_OPEN expression ROUND_CLOSED
                       | literal
;
*/

/* operators */


/* literals */
literal              ::= IDENTIFIER
                       | INTEGER:i             {: RESULT = new Integer(i); :}
                       | TRUE                  {: RESULT = Boolean.TRUE; :}
                       | FALSE                 {: RESULT = Boolean.FALSE; :}
                       | UNDEFINED             {: RESULT = Undefined.UNDEFINED; :}
                       | functionDeclaration
                       | STRING:i              {: RESULT = new String(i); :}
                       | SQUARE_OPEN expressions SQUARE_CLOSED
;

functionDeclaration  ::= COLON ROUND_OPEN functionArguments ROUND_CLOSED CURLY_OPEN instructions CURLY_CLOSED;
functionArguments    ::= functionArguments:l COMMA IDENTIFIER:i {: l.add(i); :}
                       | IDENTIFIER:i {: RESULT = new LinkedList<Identifier>(); RESULT.add(i); :}
;