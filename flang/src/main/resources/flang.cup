package ch.ffhs.fac.flang.parser;

import ch.ffhs.fac.flang.runtime.*;
import ch.ffhs.fac.flang.runtime.expressions.*;
import ch.ffhs.fac.flang.runtime.expressions.operations.*;
import ch.ffhs.fac.flang.runtime.instructions.*;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:
   
:};


/** Terminals */

// keywords

terminal     TRUE, FALSE, UNDEFINED;
terminal     AND, OR;
terminal     FOR, FROM, TO, BY;
terminal     WHILE;
terminal     IF, ELSE;
terminal     END, RETURN;
	
// brackets
terminal     ROUND_OPEN, ROUND_CLOSED, CURLY_OPEN, CURLY_CLOSED, SQUARE_OPEN, SQUARE_CLOSED;

// arithmetic
terminal     ASSIGN, COLON, COMMA, PLUS, MINUS, ASTERISK, SLASH;
terminal     EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
terminal     UMINUS;


// literals
terminal String IDENTIFIER;
terminal String STRING;
terminal Integer INTEGER;


/** Non-Terminals */
non terminal Document document;
non terminal List<Instruction> instructions;
non terminal Instruction instruction;

non terminal Instruction if;
non terminal Instruction for;
non terminal Instruction while;
non terminal Instruction assignment;
non terminal Expression functionCall;
non terminal LinkedList<ch.ffhs.fac.flang.runtime.literals.Identifier> functionArguments;
non terminal Expression functionDeclaration;
non terminal LinkedList<Expression> expressions;
non terminal Expression expression;
/*
We keep this for now - it has been replaced by "%prec" and "precedence left"
non terminal Expression expressionPriority1;
non terminal Expression expressionPriority2;
non terminal Expression expressionPriority3;
non terminal Expression expressionPriority4;
non terminal Expression expressionPriority5;
non terminal Expression expressionPriority6;
non terminal Expression expressionPriority7;
non terminal Expression expressionPriority8;
*/

non terminal Literal literal;
non terminal ch.ffhs.fac.flang.runtime.literals.Identifier identifier;
/** Precedences */
precedence left OR;
precedence left AND;

precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH;
precedence left UMINUS;


/** ============= GRAMMAR ============= */

start with document;

document             ::= instructions:i                 {: RESULT = new Document(i); :};
instructions         ::= instructions:l instruction:i   {: l.add(i); :}
                       | instruction:i                  {: RESULT = new LinkedList<Instruction>(); RESULT.add(i); :}
;

instruction          ::= assignment:i                   {: RESULT = i; :}
                       | END                            {: :}
                       | RETURN expression              {: :}
                       | if                             {: :}
                       | while                          {: :}
                       | for                            {: :}
                       | functionCall                   {: :}
;

/* instructions */
assignment           ::= identifier:i ASSIGN expression:e                   {: RESULT = new Assignment(i, e); :};
functionCall         ::= identifier:i ROUND_OPEN expressions:e ROUND_CLOSED {: :}
                       | functionCall ROUND_OPEN expressions:e ROUND_CLOSED {: :}
;


if                   ::= IF expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | IF expression CURLY_OPEN instructions CURLY_CLOSED ELSE CURLY_OPEN instructions CURLY_CLOSED {: :}
;
while                ::= WHILE expression CURLY_OPEN instructions CURLY_CLOSED {: :};
for                  ::= FOR identifier TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR identifier TO expression BY expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR identifier FROM expression TO expression CURLY_OPEN instructions CURLY_CLOSED {: :}
                       | FOR identifier FROM expression TO expression BY expression CURLY_OPEN instructions CURLY_CLOSED {: :}
;


/* expressions */
expressions          ::= expressions:l COMMA expression:i {: l.add(i); :}
                       | expression:i                     {: RESULT = new LinkedList<Expression>(); RESULT.add(i); :}
;


expression           ::= expression:l OR expression:r              {: RESULT = new BiOperand(l, BiOperand.Type.OR, r); :}
                       | expression:l AND expression:r             {: RESULT = new BiOperand(l, BiOperand.Type.AND, r); :}
                       | expression:l EQUAL expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.EQUAL, r); :}
                       | expression:l NOT_EQUAL expression:r       {: RESULT = new BiOperand(l, BiOperand.Type.NOT_EQUAL, r); :}
                       | expression:l LESS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.LESS, r); :}
                       | expression:l LESS_EQUAL expression:r      {: RESULT = new BiOperand(l, BiOperand.Type.LESS_EQUAL, r); :}
                       | expression:l GREATER expression:r         {: RESULT = new BiOperand(l, BiOperand.Type.GREATER, r); :}
                       | expression:l GREATER_EQUAL expression:r   {: RESULT = new BiOperand(l, BiOperand.Type.GREATER_EQUAL, r); :}
                       | expression:l PLUS expression:r            {: RESULT = new BiOperand(l, BiOperand.Type.PLUS, r); :}
                       | expression:l MINUS expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.MINUS, r); :}
                       | expression:l ASTERISK expression:r        {: RESULT = new BiOperand(l, BiOperand.Type.ASTERISK, r); :}
                       | expression:l SLASH expression:r           {: RESULT = new BiOperand(l, BiOperand.Type.SLASH, r); :}
                       | MINUS expression:i                        {: RESULT = new UnaryOperand(i, UnaryOperand.Type.MINUS); :} %prec UMINUS
                       | ROUND_OPEN expression:i ROUND_CLOSED      {: RESULT = i; :}
                       | literal:i                                 {: RESULT = new LiteralWrapper(i); :}
;

/*
 Older versions of CUP forced the user to write unambiguous grammars, but now there is a construct allowing the
 user to specify precedences and associativities for terminals.
expression           ::= expressionPriority1;
expressionPriority1  ::= expressionPriority1 OR expressionPriority2
                       | expressionPriority2
;
expressionPriority2  ::= expressionPriority2 AND expressionPriority3
                       | expressionPriority3
;
expressionPriority3  ::= expressionPriority3 EQUAL expressionPriority4
                       | expressionPriority3 NOT_EQUAL expressionPriority4
                       | expressionPriority4
;
expressionPriority4  ::= expressionPriority4 LESS expressionPriority5
                       | expressionPriority4 LESS_EQUAL expressionPriority5
                       | expressionPriority4 GREATER expressionPriority5
                       | expressionPriority4 GREATER_EQUAL expressionPriority5
                       | expressionPriority5
;
expressionPriority5  ::= expressionPriority5 PLUS expressionPriority6
                       | expressionPriority5 MINUS expressionPriority6
                       | expressionPriority6
;
expressionPriority6  ::= expressionPriority6 ASTERISK expressionPriority7
                       | expressionPriority6 SLASH expressionPriority7
                       | expressionPriority7
;
expressionPriority7  ::= MINUS expressionPriority8
                       | expressionPriority8
;
expressionPriority8  ::= ROUND_OPEN expression:i ROUND_CLOSED
                       | literal
;
*/

/* operators */


/* literals */
literal              ::= identifier:i          {: RESULT = i; :}
                       | INTEGER:i             {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Integer(i); :}
                       | TRUE                  {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.TRUE; :}
                       | FALSE                 {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.FALSE; :}
                       | UNDEFINED             {: RESULT = ch.ffhs.fac.flang.runtime.literals.Undefined.UNDEFINED; :}
                       | functionDeclaration
                       | STRING:i              {: RESULT = new ch.ffhs.fac.flang.runtime.literals.String(i); :}
                       | SQUARE_OPEN expressions:i SQUARE_CLOSED
;

identifier           ::= IDENTIFIER:i          {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Identifier(i); :};

functionDeclaration  ::= COLON ROUND_OPEN functionArguments ROUND_CLOSED CURLY_OPEN instructions CURLY_CLOSED;
functionArguments    ::= functionArguments:l COMMA identifier:i {: l.add(i); :}
                       | identifier:i {: RESULT = new LinkedList<ch.ffhs.fac.flang.runtime.literals.Identifier>(); RESULT.add(i); :}
;