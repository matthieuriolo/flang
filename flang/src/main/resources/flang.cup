package ch.ffhs.fac.flang.parser;

import java_cup.runtime.Symbol;

import ch.ffhs.fac.flang.parser.interfaces.*;
import ch.ffhs.fac.flang.parser.exceptions.*;
import ch.ffhs.fac.flang.runtime.*;
import ch.ffhs.fac.flang.runtime.expressions.*;
import ch.ffhs.fac.flang.runtime.instructions.*;

import java.util.*;
import java.math.BigDecimal;

parser code {:
	@SuppressWarnings("unchecked")
	public List<Instruction> parseInstructions() throws java.lang.Exception {
		final var symbol = parse();
		return (List<Instruction>) symbol.value;
	}
	
	public Document parseDocument() throws java.lang.Exception {
		return new Document(parseInstructions());
	}
	
	private void setLoc(final LocatedInText o, final int line, final int col) {
		o.setLocation(new Location(line + 1, col));
	}
	
	@Override
	public void syntax_error(Symbol cur_token)
	{
		List<Integer> ids = expected_token_ids();
		LinkedList<String> list = new LinkedList<String>();
		for (Integer expected : ids){
			list.add(symbl_name_from_id(expected));
		}
		
		throw new ParserException(list, new Location(cur_token.left + 1, cur_token.right));
	}
:};


/** Terminals */

// keywords

terminal     TRUE, FALSE, UNDEFINED;
terminal     AND, OR;
terminal     FOR, FROM, TO, BY;
terminal     WHILE;
terminal     IF, ELSE;
terminal     END, RETURN;
	
// brackets
terminal     ROUND_OPEN, ROUND_CLOSED, CURLY_OPEN, CURLY_CLOSED, SQUARE_OPEN, SQUARE_CLOSED;

// arithmetic
terminal     ASSIGN, COLON, COMMA, PLUS, MINUS, ASTERISK, SLASH;
terminal     EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
terminal     UMINUS;


// literals
terminal     String IDENTIFIER;
terminal     String STRING;
terminal     BigDecimal DECIMAL;


/** Non-Terminals */
non terminal List<Instruction> instructions;
non terminal Instruction instruction;

non terminal Instruction if;
non terminal Instruction for;
non terminal Instruction while;
non terminal Instruction assignment;
non terminal Expression functionCall;
non terminal Instruction functionProcedure;
non terminal LinkedList<Identifier> functionArguments;
non terminal Literal functionDeclaration;
non terminal LinkedList<Expression> indexes;
non terminal LinkedList<Expression> expressions;
non terminal Expression expression;
non terminal Expression operation;
non terminal Expression arrayBuilder;
non terminal Expression access;

non terminal Literal literal;
non terminal Identifier identifier;


/** Precedences */
precedence left OR;
precedence left AND;

precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH;
precedence left UMINUS;


/** ============= GRAMMAR ============= */

start with instructions;

instructions         ::= instructions:l instruction:i                                                                                 {: RESULT = l; l.add(i); :}
                       | /* empty */                                                                                                  {: RESULT = new LinkedList<Instruction>(); :}
;

instruction          ::= assignment:i                                                                                                 {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | END:i                                                                                                        {: RESULT = new Return(); parser.setLoc(RESULT, ileft, iright); :}
                       | RETURN expression:i                                                                                          {: RESULT = new Return(i); parser.setLoc(RESULT, ileft, iright); :}
                       | if:i                                                                                                         {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | while:i                                                                                                      {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | for:i                                                                                                        {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | functionProcedure:i                                                                                          {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
;

/* helper */

indexes              ::= indexes:i SQUARE_OPEN expression:e SQUARE_CLOSED                                                             {: RESULT = i; i.add(e); :}
                       | SQUARE_OPEN expression:e SQUARE_CLOSED                                                                       {: RESULT = new LinkedList<Expression>(); RESULT.add(e); :}
;


/* instructions */
assignment           ::= identifier:i ASSIGN expression:e                                                                             {: RESULT = new Assignment(i, e); :}
                       | identifier:s indexes:i ASSIGN expression:e                                                                   {: RESULT = new IndexAssignment(s, i, e); :}
;

functionProcedure    ::= identifier:i ROUND_OPEN expressions:e ROUND_CLOSED                                                           {: RESULT = new ProcedureCall(i, e); :}
                       | functionCall:c ROUND_OPEN expressions:e ROUND_CLOSED                                                         {: RESULT = new ProcedureCall(c, e); :}
;


if                   ::= IF expression:e CURLY_OPEN instructions:i CURLY_CLOSED                                                       {: RESULT = new If(e, i); :}
                       | IF expression:e CURLY_OPEN instructions:i CURLY_CLOSED ELSE CURLY_OPEN instructions:o CURLY_CLOSED           {: RESULT = new If(e, i, o); :}
;
while                ::= WHILE expression:e CURLY_OPEN instructions:i CURLY_CLOSED                                                    {: RESULT = new While(e, i); :};
for                  ::= FOR identifier:i TO expression:t CURLY_OPEN instructions:s CURLY_CLOSED                                      {: RESULT = new For(i, BigDecimal.ZERO, t, BigDecimal.ONE, s); :}
                       | FOR identifier:i TO expression:t BY expression:b CURLY_OPEN instructions:s CURLY_CLOSED                      {: RESULT = new For(i, BigDecimal.ZERO, t, b, s); :}
                       | FOR identifier:i FROM expression:f TO expression:t CURLY_OPEN instructions:s CURLY_CLOSED                    {: RESULT = new For(i, f, t, BigDecimal.ONE, s); :}
                       | FOR identifier:i FROM expression:f TO expression:t BY expression:b CURLY_OPEN instructions:s CURLY_CLOSED    {: RESULT = new For(i, f, t, b, s); :}
;


/* expressions */
expressions          ::= expressions:l COMMA expression:i                                                                             {: RESULT = l; l.add(i); :}
                       | expression:i                                                                                                 {: RESULT = new LinkedList<Expression>(); RESULT.add(i); :}
                       | /* empty */                                                                                                  {: RESULT = new LinkedList<Expression>(); :}
;                                                                                                                                     


expression           ::= operation:i                                                                                                  {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | ROUND_OPEN expression:i ROUND_CLOSED                                                                         {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | functionCall:i                                                                                               {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | literal:i                                                                                                    {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | identifier:i                                                                                                 {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | arrayBuilder:i                                                                                               {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
                       | access:i                                                                                                     {: RESULT = i; parser.setLoc(RESULT, ileft, iright); :}
;

access               ::= identifier:s indexes:i                                                                                       {: RESULT = new Access(s, i); :}
;


arrayBuilder         ::= SQUARE_OPEN expressions:i SQUARE_CLOSED                                                                      {: RESULT = new ArrayBuilder(i); :}
;


/* operators */
operation            ::= expression:l OR expression:r                                                                                 {: RESULT = new BinaryOperation(l, BinaryOperation.Type.OR, r); :}
                       | expression:l AND expression:r                                                                                {: RESULT = new BinaryOperation(l, BinaryOperation.Type.AND, r); :}
                       | expression:l EQUAL expression:r                                                                              {: RESULT = new BinaryOperation(l, BinaryOperation.Type.EQUAL, r); :}
                       | expression:l NOT_EQUAL expression:r                                                                          {: RESULT = new BinaryOperation(l, BinaryOperation.Type.NOT_EQUAL, r); :}
                       | expression:l LESS expression:r                                                                               {: RESULT = new BinaryOperation(l, BinaryOperation.Type.LESS, r); :}
                       | expression:l LESS_EQUAL expression:r                                                                         {: RESULT = new BinaryOperation(l, BinaryOperation.Type.LESS_EQUAL, r); :}
                       | expression:l GREATER expression:r                                                                            {: RESULT = new BinaryOperation(l, BinaryOperation.Type.GREATER, r); :}
                       | expression:l GREATER_EQUAL expression:r                                                                      {: RESULT = new BinaryOperation(l, BinaryOperation.Type.GREATER_EQUAL, r); :}
                       | expression:l PLUS expression:r                                                                               {: RESULT = new BinaryOperation(l, BinaryOperation.Type.PLUS, r); :}
                       | expression:l MINUS expression:r                                                                              {: RESULT = new BinaryOperation(l, BinaryOperation.Type.MINUS, r); :}
                       | expression:l ASTERISK expression:r                                                                           {: RESULT = new BinaryOperation(l, BinaryOperation.Type.ASTERISK, r); :}
                       | expression:l SLASH expression:r                                                                              {: RESULT = new BinaryOperation(l, BinaryOperation.Type.SLASH, r); :}
                       | MINUS expression:i                                                                                           {: RESULT = new UnaryOperation(i, UnaryOperation.Type.MINUS); :} %prec UMINUS
;                       

/* literals */
literal              ::= DECIMAL:i                                                                                                    {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Decimal(i); :}
                       | TRUE                                                                                                         {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.TRUE; :}
                       | FALSE                                                                                                        {: RESULT = ch.ffhs.fac.flang.runtime.literals.Boolean.FALSE; :}
                       | UNDEFINED                                                                                                    {: RESULT = ch.ffhs.fac.flang.runtime.literals.Undefined.UNDEFINED; :}
                       | functionDeclaration:i                                                                                        {: RESULT = i; :}
                       | STRING:i                                                                                                     {: RESULT = new ch.ffhs.fac.flang.runtime.literals.String(i); :}
;

identifier           ::= IDENTIFIER:i                                                                                                 {: RESULT = new Identifier(i); :};

functionDeclaration  ::= COLON ROUND_OPEN ROUND_CLOSED CURLY_OPEN instructions:i CURLY_CLOSED                                         {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Function(i); :}
                       | COLON ROUND_OPEN functionArguments:a ROUND_CLOSED CURLY_OPEN instructions:i CURLY_CLOSED                     {: RESULT = new ch.ffhs.fac.flang.runtime.literals.Function(a, i); :};
functionArguments    ::= functionArguments:l COMMA identifier:i                                                                       {: RESULT = l;  l.add(i); parser.setLoc(i, ileft, iright); :}
                       | identifier:i                                                                                                 {: RESULT = new LinkedList<Identifier>(); RESULT.add(i); parser.setLoc(i, ileft, iright); :}
;
functionCall         ::= identifier:i ROUND_OPEN expressions:e ROUND_CLOSED                                                           {: RESULT = new FunctionCall(i, e); :}
                       | functionCall:c ROUND_OPEN expressions:e ROUND_CLOSED                                                         {: RESULT = new FunctionCall(c, e); :}
;